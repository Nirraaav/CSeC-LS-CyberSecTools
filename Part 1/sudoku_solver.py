# -*- coding: utf-8 -*-
"""faster.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/169XAnjpD2bAuLqlmefxnn2sZMjhUBbM4
"""

import subprocess
import re
from copy import deepcopy

def write_to_file(message):
    with open('sudoku_conversation.txt', 'a') as f:
        f.write(f"{message}\n")

def get_empty_cell(board):
    for i in range(9):
        for j in range(9):
            if board[i][j] == 0:
                return i, j
    return None

def is_valid(board, i, j, num):
    for k in range(9):
        if board[i][k] == num or board[k][j] == num:
            return False
    for k in range(3):
        for l in range(3):
            if board[3*(i//3)+k][3*(j//3)+l] == num:
                return False
    return True

def solve_sudoku(board):
    cell = get_empty_cell(board)
    if cell is None:
        return True
    i, j = cell
    for num in range(1, 10):
        if is_valid(board, i, j, num):
            board[i][j] = num
            if solve_sudoku(board):
                return True
            board[i][j] = 0
    return False

def print_board(board):
    for row in board:
        print(row)
    print('-' * 30)  # Add a line of 30 dashes after each board

def check_solved(board):
    return all(all(cell != 0 for cell in row) for row in board)

def main():
    process = subprocess.Popen(["./sudoku"], stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True, bufsize=1)
    count = 0
    for k in range(840):
        sudoku = []
        while len(sudoku) < 9:
            line = process.stdout.readline().strip()
            write_to_file(f"From executable: {line}")
            if 'Snuday' in line:
                count += 1
            if re.match(r"\| [0-9\.] [0-9\.] [0-9\.] \|", line):
                row = [0 if char == "." else int(char) for char in line if char in "0123456789."]
                sudoku.append(row)

        original_sudoku = deepcopy(sudoku)
        if solve_sudoku(sudoku):
            print_board(sudoku)
            if check_solved(sudoku):
                unfilled_cells = [(i, j) for i in range(9) for j in range(9) if original_sudoku[i][j] == 0]
                for i, (row, col) in enumerate(unfilled_cells):
                    input_line = f"{row} {col} {sudoku[row][col]}\n"
                    process.stdin.write(input_line)
                    write_to_file(f"To executable: {input_line.strip()}")
                    process.stdin.flush()
                    if i != len(unfilled_cells) - 1:
                        for _ in range(14):
                            line = process.stdout.readline()
                            write_to_file(f"From executable: {line.strip()}")
        else:
            print("No solution exists")
            print('-' * 30)  # Add a line after "No solution exists" message as well

    while (line := process.stdout.readline()):
        write_to_file(f"From executable: {line.strip()}")
        print(line.strip())

    process.stdin.close()
    process.wait()

if __name__ == "__main__":
    main()